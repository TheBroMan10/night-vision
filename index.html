<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Night Vision Frame Stacking</title>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { width:100vw; height:100vh; display:block; }
  .controls { position:fixed; bottom:10px; background:rgba(0,0,0,0.6); padding:10px; border-radius:10px; display:flex; gap:10px; color:white; font-family:sans-serif; }
  label { display:flex; flex-direction:column; font-size:12px; align-items:center; color:white; }
</style>
</head>
<body>

<video id="video" autoplay playsinline style="display:none;"></video>
<canvas id="canvas"></canvas>

<div class="controls">
  <label>Brightness
    <input id="brightness" type="range" min="0.5" max="5" step="0.1" value="2">
  </label>
  <label>Contrast
    <input id="contrast" type="range" min="0.5" max="5" step="0.1" value="2">
  </label>
</div>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const brightnessSlider = document.getElementById('brightness');
const contrastSlider = document.getElementById('contrast');

// Frame stacking settings
const FRAME_COUNT = 20; // ~5x Live Photo
const buffer = [];
const downscaleWidth = 320; // reduce resolution for speed
const downscaleHeight = 240;

canvas.width = downscaleWidth;
canvas.height = downscaleHeight;

navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
  .then(stream => { video.srcObject = stream; })
  .catch(err => { alert("Camera access failed: " + err); });

function applyFiltersAndDraw() {
  // Draw current frame to temp canvas
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = downscaleWidth;
  tempCanvas.height = downscaleHeight;
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.drawImage(video, 0, 0, downscaleWidth, downscaleHeight);
  const frame = tempCtx.getImageData(0, 0, downscaleWidth, downscaleHeight);

  // Add to buffer
  if (buffer.length >= FRAME_COUNT) buffer.shift();
  buffer.push(frame);

  // Average frames
  const avgFrame = ctx.createImageData(downscaleWidth, downscaleHeight);
  for (let i = 0; i < avgFrame.data.length; i += 4) {
    let r=0,g=0,b=0;
    buffer.forEach(f => { r += f.data[i]; g += f.data[i+1]; b += f.data[i+2]; });
    const len = buffer.length;
    avgFrame.data[i] = r/len;
    avgFrame.data[i+1] = g/len;
    avgFrame.data[i+2] = b/len;
    avgFrame.data[i+3] = 255; // alpha
  }

  // Apply simple brightness/contrast
  const brightness = parseFloat(brightnessSlider.value);
  const contrast = parseFloat(contrastSlider.value);
  for (let i = 0; i < avgFrame.data.length; i += 4) {
    avgFrame.data[i] = ((avgFrame.data[i]-128)*contrast + 128) * brightness;
    avgFrame.data[i+1] = ((avgFrame.data[i+1]-128)*contrast + 128) * brightness;
    avgFrame.data[i+2] = ((avgFrame.data[i+2]-128)*contrast + 128) * brightness;
    // clamp
    avgFrame.data[i] = Math.min(255, Math.max(0, avgFrame.data[i]));
    avgFrame.data[i+1] = Math.min(255, Math.max(0, avgFrame.data[i+1]));
    avgFrame.data[i+2] = Math.min(255, Math.max(0, avgFrame.data[i+2]));
  }

  ctx.putImageData(avgFrame, 0, 0);
  requestAnimationFrame(applyFiltersAndDraw);
}

video.addEventListener('play', () => {
  applyFiltersAndDraw();
});
</script>
</body>
</html>
